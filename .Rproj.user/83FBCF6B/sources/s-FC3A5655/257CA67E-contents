class: inverse, center, middle
# Package overview and example


---
# Installing {ppseq}

**Development** version from GitHub: `remotes::install_github("zabore/ppseq")`

**Production** version from CRAN: `install.packages("ppseq")`


---
# Atezolizumab for mUC

<p align="center"><img src="images/atezo-headlines.png" width=90%></p>

.small[
https://www.cancernetwork.com/view/atezolizumab-indication-in-us-withdrawn-for-previously-treated-metastatic-urothelial-cancer
https://www.onclive.com/view/roche-withdraws-atezolizumab-prior-platinum-treated-metastatic-bladder-cancer-indication-in-the-united-states
https://ascopost.com/news/march-2021/atezolizumab-s-indication-in-previously-treated-metastatic-bladder-cancer-is-withdrawn/
]


---
# Original dose-expansion design

.large[
**Primary aim**: evaluate safety, pharmacodynamics, pharmacokinetics

* Expansion cohort in mUC not originally planned

* Added through **protocol amendment**

* Enrolled **95 patients**

* Single **futility look**: stop if 0 responses in first 14 patients

    - At most 4.4% chance of no responses if true rate is 20% or higher
]

<br>
<br>

.small[
Powles T, Eder JP, Fine GD, Braiteh FS, Loriot Y, Cruz C, Bellmunt J, Burris HA, Petrylak DP, Teng SL, Shen X, Boyd Z, Hegde PS, Chen DS, Vogelzang NJ. MPDL3280A (anti-PD-L1) treatment leads to clinical activity in metastatic bladder cancer. Nature. 2014 Nov 27;515(7528):558-62
]


---
# Re-design of dose-expansion study

.large[
* Assume **null** rate of 0.1 and **alternative** rate of 0.2

* Maximum sample size **N = 95**

* Check for futility after **every 5 patients**

* **Posterior thresholds**: 0, 0.7, 0.74, 0.78, 0.82, 0.86, 0.9, 0.92, 0.93, 0.94, 0.95, 0.96,
0.97, 0.98, 0.99, 0.999, 0.9999, 0.99999, and 1

* **Predictive thresholds**: 0.05, 0.1, 0.15, and 0.2

]


---
# Determine type I error and power

<p align="center"><img src="images/power-type1.jpg" width=60%></p>

.large[
- Need to determine **type I error** and **power** of decision thresholds
- Use `calibrate_thresholds()` to evaluate a grid of thresholds
  - Jointly calibrates **posterior** and **predictive** thresholds
]


---
# calibrate_thresholds()

```{r}
library(ppseq)
```

```{r eval = FALSE}
one_sample_cal_tbl <-
  calibrate_thresholds(
    p_null = 0.1,
    p_alt = 0.2,
    n = seq(5, 95, 5),
    N = 95,
    pp_threshold = c(0, 0.7, 0.74, 0.78, 0.82, 0.86, 0.9, 0.92, 0.93, 0.94,
                     0.95, 0.96, 0.97, 0.98, 0.99, 0.999, 0.9999, 0.99999, 1),
    ppp_threshold = seq(0.05, 0.2, 0.05),
    direction = "greater",
    delta = NULL,
    prior = c(0.5, 0.5),
    S = 5000,
    nsim = 1000
    )
```


---
# print() calibrate_thresholds() resuts

```{r eval = FALSE}
print(one_sample_cal_tbl, type1_range = c(0.01, 0.2), minimum_power = 0.7)
```

.scroll-output[
```{r echo = FALSE}
gt::gt(dplyr::filter(one_sample_cal_tbl$res_summary, 
                     prop_pos_null >= 0.01, 
                     prop_pos_null <= 0.2, 
                     prop_pos_alt >= 0.7))
```
]


---
# optimize_design()

```{r eval = FALSE}
optimize_design(
  one_sample_cal_tbl,
  type1_range = c(0.05, 0.1),
  minimum_power = 0.7
)
```

```{r echo = FALSE}
opt <- 
  optimize_design(
  one_sample_cal_tbl,
  type1_range = c(0.01, 0.2),
  minimum_power = 0.7
)
```

**Optimal accuracy design:**

```{r echo = FALSE}
gt::gt(opt$`Optimal accuracy design:`)
```

**Optimal efficiency design:**

```{r echo = FALSE}
gt::gt(opt$`Optimal efficiency design:`)
```


---
# plot()

```{r eval = FALSE}
plot(one_sample_cal_tbl, type1_range = c(0.01, 0.2), minimum_power = 0.7, plotly = TRUE)
```

```{r echo = FALSE}
ptest <- 
  plot(one_sample_cal_tbl, 
     type1_range = c(0.01, 0.2), 
     minimum_power = 0.7,
     plotly = TRUE)
```

.pull-left[
**Accuracy:**
.center[
```{r echo = FALSE, fig.width = 6, fig.height = 5}
ptest[[1]]
```
]
]

.pull-right[
**Efficiency:**
.center[
```{r echo = FALSE, fig.width = 6, fig.height = 5}
ptest[[2]]
```
]
]


---
# Selected optimal design

.pull-left[
**Optimal efficiency design**

- Only 39 patients under the null on average

- Type I error of 0.06

- Power of 79.6%
]

.pull-left[
**Original design**

- Average sample size under the null of 76

- Type I error of 0.005

- Power of 52.8%
]


---
# calc_decision_rules()

```{r eval = FALSE}
one_sample_decision_tbl <-
  calc_decision_rules(
    n = seq(5, 95, 5),
    N = 95,
    theta = 0.92,
    ppp = 0.1,
    p0 = 0.1,
    direction = "greater",
    delta = NULL,
    prior = c(0.5, 0.5),
    S = 5000
    )
```


---
# calc_decision_rules()

```{r eval = FALSE}
one_sample_decision_tbl
```

.scroll-output[
```{r echo = FALSE}
gt::gt(one_sample_decision_tbl)
```
]


---
# plot()

```{r message = FALSE, fig.width = 10, fig.height = 6, fig.align='center'}
plot(one_sample_decision_tbl)
```



---
# Additional features

.large[
* All demonstrated functions also available for **two-sample case**
  - i.e. Experimental vs standard-of-care treatment arms

* `calibrate_thresholds()` is parallelized using the {future} and {furrr} packages
  - Set up a call to `future::plan()` appropriate for your system
  - Example:  `future::plan(future::multicore(workers = 76))`
]





library(ppseq)
library(tictoc)

eval_thresh <- function(data, pp_threshold, ppp_threshold,
                        direction = "greater", p0 = NULL, delta = 0, 
                        prior = c(0.5, 0.5), S = 5000, N) {
  decision <- NULL
  ppp <- NULL
  for(i in 1:nrow(data)) {
    
    if(ncol(data) == 4) {
      ppp[i] <- calc_predictive(y = c(data$y0[i], data$y1[i]), 
                                n = c(data$n0[i], data$n1[i]),
                                direction = direction, p0 = p0, delta = delta, 
                                prior = prior, S = S, N = N, 
                                theta = pp_threshold) 
    } else if(ncol(data) == 2) {
      ppp[i] <- calc_predictive(y = data$y1[i], n = data$n1[i],
                                direction = direction, p0 = p0, delta = delta, 
                                prior = prior, S = S, N = N, 
                                theta = pp_threshold) 
    }
    decision[i] <- ppp[i] < ppp_threshold
    if(decision[i] == TRUE) break
  }
  res0 <- tibble::add_column(
    data[ifelse(any(decision == TRUE), 
                which(decision == TRUE), 
                length(decision)), ],
    pp_threshold = pp_threshold,
    ppp_threshold = ppp_threshold,
    ppp = ppp[ifelse(any(decision == TRUE), 
                     which(decision == TRUE), 
                     length(decision))])
  
  if(ncol(data) == 4) {
    res <- dplyr::mutate(
      res0,
      positive = dplyr::case_when(
        sum(n0, n1) == sum(N) & ppp > pp_threshold ~ TRUE,
        sum(n0, n1) == sum(N) & ppp < pp_threshold ~ FALSE,
        sum(n0, n1) != sum(N) ~ FALSE)
    )
  } else if(ncol(data) == 2) {
    res <- dplyr::mutate(
      res0,
      positive = dplyr::case_when(
        n1 == N & ppp > pp_threshold ~ TRUE,
        n1 == N & ppp < pp_threshold ~ FALSE,
        n1 != N ~ FALSE)
    )
  }
  return(res)
}


sim_dat1 <- function(p, n) {
  if(length(p) == 2) {
    if(length(n) == 2 & is.matrix(n) == FALSE) {n <- matrix(n, nrow = 1)}
    y0 <- stats::rbinom(n = 1, size = n[1, 1], prob = p[1]) 
    y1 <- stats::rbinom(n = 1, size = n[1, 2], prob = p[2]) 
    if(length(n) > 2) {
      for(i in 2:nrow(n)) { 
        y0 <- c(y0, y0[length(y0)] + stats::rbinom(n = 1, 
                                                   size = n[i, 1] - n[i - 1, 1], 
                                                   prob = p[1])) 
        y1 <- c(y1, y1[length(y1)] + stats::rbinom(n = 1, 
                                                   size = n[i, 2] - n[i - 1, 2], 
                                                   prob = p[2])) 
      }
    }
    return(tibble::tibble(n0 = n[, 1],
                          n1 = n[, 2],
                          y0 = y0,
                          y1 = y1))
  } else if(length(p) == 1){
    y1 <- stats::rbinom(n = 1, size = n[1], prob = p) 
    if(length(n) > 1) {
      for(i in 2:length(n)) { 
        y1 <- c(y1,  y1[length(y1)] + 
                  stats::rbinom(n = 1, size = n[i] - n[i - 1], prob = p))
      }
    }
    return(tibble::tibble(n1 = n, y1 = y1))
  }
}


# This function to evaluate Simon's design is written specifically for the case of Simon's minimax design with alph = 0.05, beta = 0.2, pu = 0.1, pa = 0.3
eval_simon <- function(data) {
  data2 <- dplyr::filter(data, n1 %in% c(15, 25))
  
  if(data2$y1[1] <= 1) {
    res <- tibble::add_column(
      data2[1, ],
      positive = FALSE
    ) 
  } else if(data2$y1[1] > 1) {
    res <- tibble::add_column(
      data2[2, ],
      positive = ifelse(data2$y1[2] > 5, TRUE, FALSE)
    )
  }
}




# This setup works on the server and on lri-r0x and uses 76 cores
future::plan(future::multicore(workers = 76))

set.seed(123)

tic()

p_null <- 0.1
p_alt <- 0.3
n <- seq(5, 25, 5)
direction <- "greater" 
delta <- NULL 
prior <- c(0.5, 0.5)
S <- 5000 
N <- 25 
nsim <- 10000
pp_threshold <- c(0, 0.7, 0.74, 0.78, 0.82, 0.86, 
                 0.9, 0.92, 0.93, 0.94, 0.95,
                 0.96, 0.97, 0.98, 0.99, 0.999, 
                 0.9999, 0.99999, 1)
ppp_threshold <- seq(0.05, 0.2, 0.05)

sim_dat_null <- 
  purrr::map(1:nsim, ~sim_dat1(p = p_null, n = n))
  
sim_dat_alt <- 
  purrr::map(1:nsim, ~sim_dat1(p = p_alt, n = n))

cross_threshold <- 
  purrr::cross_df(list(pp_threshold = pp_threshold, 
                       ppp_threshold = ppp_threshold))

p0 <- if(length(p_null) == 1) 
  p_null else if(length(p_null) == 2)
    NULL

res_null <- 
  furrr::future_map(
    sim_dat_null,
    function(x) 
      furrr::future_pmap_dfr(cross_threshold,
                             function(pp_threshold, ppp_threshold) 
                               eval_thresh(x, pp_threshold, ppp_threshold,
                                           direction = direction, p0 = p0, 
                                           delta = delta, prior = prior, 
                                           S = S, N = N), 
                             .options = furrr::furrr_options(seed = TRUE)), 
    .options = furrr::furrr_options(seed = TRUE)
  )

res_alt <- 
  furrr::future_map(
    sim_dat_alt,
    function(x) 
      furrr::future_pmap_dfr(cross_threshold,
                             function(pp_threshold, ppp_threshold) 
                               eval_thresh(x, pp_threshold, ppp_threshold,
                                           direction = direction, p0 = p0, 
                                           delta = delta, prior = prior, 
                                           S = S, N = N), 
                             .options = furrr::furrr_options(seed = TRUE)), 
    .options = furrr::furrr_options(seed = TRUE)
  )

res_df_null <- 
  dplyr::bind_rows(
    res_null,
    .id = "sim_num"
  )

res_df_alt <- 
  dplyr::bind_rows(
    res_alt,
    .id = "sim_num"
  )

res_df <- 
  dplyr::full_join(
    dplyr::select(
      dplyr::rename(res_df_null, n1_null = n1, positive_null = positive),
      -ppp, -y1),
    dplyr::select(
      dplyr::rename(res_df_alt, n1_alt = n1, positive_alt = positive),
      -ppp, -y1)
  )
  
res_summary <- 
  dplyr::ungroup(
    dplyr::summarize(
      dplyr::group_by(res_df, pp_threshold, ppp_threshold),
      mean_n1_null = mean(n1_null),
      prop_pos_null = mean(positive_null),
      prop_stopped_null = mean(n1_null < N),
      mean_n1_alt = mean(n1_alt),
      prop_pos_alt = mean(positive_alt),
      prop_stopped_alt = mean(n1_alt < N)
    )
  )

simon_null <- 
  furrr::future_map_dfr(
    sim_dat_null, eval_simon, 
    .options = furrr::furrr_options(seed = TRUE)
  )

simon_alt <- 
  furrr::future_map_dfr(
    sim_dat_alt, eval_simon, 
    .options = furrr::furrr_options(seed = TRUE)
  )

simon_summary <- 
  dplyr::summarize(
    dplyr::bind_cols(
      dplyr::select(
        dplyr::rename(simon_null, n1_null = n1, positive_null = positive),
        -y1
        ),
      dplyr::select(
        dplyr::rename(simon_alt, n1_alt = n1, positive_alt = positive),
        -y1
        )
      ),
    mean_n1_null = mean(n1_null),
    prop_pos_null = mean(positive_null),
    prop_stopped_null = mean(n1_null < N),
    mean_n1_alt = mean(n1_alt),
    prop_pos_alt = mean(positive_alt),
    prop_stopped_alt = mean(n1_alt < N)
    )

# create empty list to return everything
x <- list()

# add the main results in
x$res_summary <- res_summary

# will return call, and all object passed to in table1 call
# the object func_inputs is a list of every object passed to the function
calibrate_thresholds_inputs <- list(p_null = p_null, 
                                    p_alt = p_alt, 
                                    n = n,
                                    direction = direction, 
                                    delta = delta, 
                                    prior = prior, 
                                    S = S, 
                                    N = N, 
                                    nsim = nsim,
                                    pp_threshold = pp_threshold, 
                                    ppp_threshold = ppp_threshold)

# create other objects to return
x$call_list <- list(calibrate_thresholds = match.call())
x$inputs <- calibrate_thresholds_inputs

# add the Simon results to the list
x$simon_res <- simon_summary

# assign a custom class for S3 plotting methods
class(x) <- c("calibrate_thresholds", class(x))

one_sample_cal_tbl <- x

toc()

save(one_sample_cal_tbl, 
     file = here::here("sim_results", "one_sample_cal_tbl.rda"))